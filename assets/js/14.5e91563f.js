(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{430:function(a,t,s){"use strict";s.r(t);var l=s(2),v=Object(l.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"是一个比较运算符-equals方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#是一个比较运算符-equals方法"}},[a._v("#")]),a._v(" "),t("strong",[a._v("==是一个比较运算符，equals方法")])]),a._v(" "),t("ol",[t("li",[t("p",[a._v("==：既可以判断基本类型，又可以判断引用类型。")])]),a._v(" "),t("li",[t("p",[a._v("==：如果判断基本类型，判断的是值是否相等。")])]),a._v(" "),t("li",[t("p",[a._v("==：如果判断引用类型，判断的是地址是否相等，及判定是不是同一个对象 。")])]),a._v(" "),t("li",[t("p",[a._v("equals：是Object类中的方法，只能判断引用类型。")])]),a._v(" "),t("li",[t("p",[a._v("equals()默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。")])])]),a._v(" "),t("h3",{attrs:{id:"hashcode方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashcode方法"}},[a._v("#")]),a._v(" "),t("strong",[a._v("hashCode方法")])]),a._v(" "),t("ol",[t("li",[t("p",[a._v("提高具有哈希结构的容器的效率。")])]),a._v(" "),t("li",[t("p",[a._v("两个引用，如果指向的是同一个对象，则哈希值肯定是一样的。")])]),a._v(" "),t("li",[t("p",[a._v("两个引用，如果指向的是不同对象，则哈希值是不一样的。")])]),a._v(" "),t("li",[t("p",[a._v("哈希值主要根据地址号来的！不能完全将哈希值等价于地址。")])]),a._v(" "),t("li",[t("p",[a._v("后面在集合中，hashCode如果需要的话，也会重写。")])])]),a._v(" "),t("h3",{attrs:{id:"finalize方法-几乎不用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finalize方法-几乎不用"}},[a._v("#")]),a._v(" "),t("strong",[a._v("Finalize方法（几乎不用）")])]),a._v(" "),t("ol",[t("li",[t("p",[a._v("当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作。")])]),a._v(" "),t("li",[t("p",[a._v("什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。")])]),a._v(" "),t("li",[t("p",[a._v("垃圾回收机制的调用，是由系统来决定，也可以通过System.gc() 主动触发垃圾回收机制。")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);