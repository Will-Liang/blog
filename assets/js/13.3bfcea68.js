(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{412:function(t,v,r){"use strict";r.r(v);var _=r(2),a=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"io流原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#io流原理"}},[t._v("#")]),t._v(" "),v("strong",[t._v("IO流原理")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。")])]),t._v(" "),v("li",[v("p",[t._v("java程序中，对于数据的输入/输出操作以“流（stream）”的方式进行。")])]),t._v(" "),v("li",[v("p",[t._v("java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入和输出数据")])]),t._v(" "),v("li",[v("p",[t._v("输入input：读取外部数据（磁盘，光盘等存储设备的数据）到程序（内存）中。")])]),t._v(" "),v("li",[v("p",[t._v("输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。")])])]),t._v(" "),v("h2",{attrs:{id:"流的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流的分类"}},[t._v("#")]),t._v(" "),v("strong",[t._v("流的分类")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("按操作数据单位不同分为：字节流(2进制文件)，字符流（文本文件）")])]),t._v(" "),v("li",[v("p",[t._v("按数据流向不同分为：输入流，输出流")])]),t._v(" "),v("li",[v("p",[t._v("按流的角色不同分为：节点流，处理流/包装流")])])]),t._v(" "),v("p",[v("img",{attrs:{src:"/blog/java/image-20220809210803070.png",alt:"image-20220809210803070"}})]),t._v(" "),v("h2",{attrs:{id:"节点流和处理流的区别和联系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#节点流和处理流的区别和联系"}},[t._v("#")]),t._v(" "),v("strong",[t._v("节点流和处理流的区别和联系")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("节点流是底层流/低级流，直接跟数据源相接。")])]),t._v(" "),v("li",[v("p",[t._v("处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更发辫的方法来完成输入输出。")])]),t._v(" "),v("li",[v("p",[t._v("处理流（包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连。")])]),t._v(" "),v("li",[v("p",[t._v("处理流的功能：")]),t._v(" "),v("p",[t._v("（1）性能的提高：主要以增加缓冲的方式来提高输入输出的效率")]),t._v(" "),v("p",[t._v("（2）操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便。")])])]),t._v(" "),v("h2",{attrs:{id:"序列化和反序列化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#序列化和反序列化"}},[t._v("#")]),t._v(" "),v("strong",[t._v("序列化和反序列化")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("序列化就是在保存数据时，保存数据的值和数据类型")])]),t._v(" "),v("li",[v("p",[t._v("反序列化就是在恢复数据时，恢复数据的值和数据类型")])]),t._v(" "),v("li",[v("p",[t._v("需要让某个对象支持序列化机制，则必须让其类时可序列化的，为了让某个类是可序列化的，该类必须实现下面两个接口之一")])])]),t._v(" "),v("p",[t._v("​\t\t(1) Serializable 这是一个标记接口，没有方法")]),t._v(" "),v("p",[t._v("​\t\t(2) Externalizable 该接口有方法要实现，因此我们一般使用Serializable接口")]),t._v(" "),v("p",[t._v("ObjectOutputStream提供序列化功能，ObjectInputStream提供反序列化功能。")]),t._v(" "),v("p",[v("strong",[t._v("注意")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("读写顺序要求一致")])]),t._v(" "),v("li",[v("p",[t._v("要求序列化或反序列化对象，需要实现Serializable")])]),t._v(" "),v("li",[v("p",[t._v("序列化的类中建议添加SerialVersionUID为了提高版本的兼容性")])]),t._v(" "),v("li",[v("p",[t._v("序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员")])]),t._v(" "),v("li",[v("p",[t._v("序列化对象时，要求里面属性的类型也需要实现序列化接口")])]),t._v(" "),v("li",[v("p",[t._v("序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化")])])]),t._v(" "),v("p",[v("img",{attrs:{src:"/blog/java/image-20220809210601052.png",alt:"image-20220809210601052"}})]),t._v(" "),v("p",[v("img",{attrs:{src:"/blog/java/image-20220809210624976.png",alt:"image-20220809210624976"}})]),t._v(" "),v("p",[v("img",{attrs:{src:"/blog/java/image-20220809210647620.png",alt:"image-20220809210647620"}})]),t._v(" "),v("h2",{attrs:{id:"转换流inputstreamreader和outputstreamwriter"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#转换流inputstreamreader和outputstreamwriter"}},[t._v("#")]),t._v(" "),v("strong",[t._v("转换流InputStreamReader和OutputStreamWriter")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("InputStreamReader：Reader的子类，可以将InputStream（字节流）包装成（转换）Reader（字符流）")])]),t._v(" "),v("li",[v("p",[t._v("OutputStreamWriter:Writer的子类，可以将OutputStream（字节流）包装成Writer（字符流）")])]),t._v(" "),v("li",[v("p",[t._v("当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文乱码问题，所以建议将字节流转换成字符流")])]),t._v(" "),v("li",[v("p",[t._v("可以在使用时指定编码格式（utf-8，gbk，gb2312等）")])])]),t._v(" "),v("h2",{attrs:{id:"properties"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#properties"}},[t._v("#")]),t._v(" "),v("strong",[t._v("Properties")])]),t._v(" "),v("ol",[v("li",[t._v("专门用于读写配置文件的集合类")]),t._v(" "),v("li",[t._v("配置文件的格式")])]),t._v(" "),v("p",[t._v("​\t\t\t键=值")]),t._v(" "),v("p",[t._v("注意：键值对不需要有空格，值不需要用用引号引起来，默认类型是String")]),t._v(" "),v("p",[t._v("Properties的常见方法")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("load:加载配置文件的键值对到Propertis对象")])]),t._v(" "),v("li",[v("p",[t._v("list:将数据显示到指定设备")])]),t._v(" "),v("li",[v("p",[t._v("getProperty(key)：根据键获取值")])]),t._v(" "),v("li",[v("p",[t._v("setProperty(key,value)：设置键值对到Properties对象")])]),t._v(" "),v("li",[v("p",[t._v("store:将Properties中的键值对存储到配置文件，在IDEA中，保存信息到配置文件，如果含有中文，会存储为unicode码")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);